<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Symbolic manipulation · Dolang.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Dolang.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><span class="toctext">Guide</span><ul><li><a class="toctext" href="index.html">Dolang.jl</a></li><li class="current"><a class="toctext" href="symbolic.html">Symbolic manipulation</a><ul class="internal"><li><a class="toctext" href="#normalize-1"><code>normalize</code></a></li><li><a class="toctext" href="#time_shift-1"><code>time_shift</code></a></li><li><a class="toctext" href="#steady_state-1"><code>steady_state</code></a></li><li><a class="toctext" href="#list_symbols-1"><code>list_symbols</code></a></li><li><a class="toctext" href="#list_variables-1"><code>list_variables</code></a></li><li><a class="toctext" href="#list_parameters-1"><code>list_parameters</code></a></li><li><a class="toctext" href="#subs-1"><code>subs</code></a></li><li><a class="toctext" href="#csubs-1"><code>csubs</code></a></li></ul></li><li><a class="toctext" href="compiler.html">Dolang&#39;s compiler</a></li><li><a class="toctext" href="examples.html">Examples</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="dev/compiler.html">Compiler internals</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Guide</li><li><a href="symbolic.html">Symbolic manipulation</a></li></ul><a class="edit-page" href="https://github.com/EconForge/Dolang.jl/blob/master/docs/src/symbolic.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Symbolic manipulation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Symbolic-manipulation-1" href="#Symbolic-manipulation-1">Symbolic manipulation</a></h1><p>One of Dolang&#39;s key features is providing an _extensible_ and _consistent_ set of routines for doing operations on symbolic objects. We&#39;ll discuss each of these routines in turn</p><ul><li><a href="symbolic.html#Symbolic-manipulation-1">Symbolic manipulation</a></li><ul><li><a href="symbolic.html#normalize-1"><code>normalize</code></a></li><li><a href="symbolic.html#time_shift-1"><code>time_shift</code></a></li><li><a href="symbolic.html#steady_state-1"><code>steady_state</code></a></li><li><a href="symbolic.html#list_symbols-1"><code>list_symbols</code></a></li><li><a href="symbolic.html#list_variables-1"><code>list_variables</code></a></li><li><a href="symbolic.html#list_parameters-1"><code>list_parameters</code></a></li><li><a href="symbolic.html#subs-1"><code>subs</code></a></li><li><a href="symbolic.html#csubs-1"><code>csubs</code></a></li></ul></ul><h2><a class="nav-anchor" id="normalize-1" href="#normalize-1"><code>normalize</code></a></h2><p>The <code>normalize</code> function converts expressions and symbols into Dolang&#39;s internal representation. There are various methods for this function:</p><pre><code class="language-none">normalize(::Symbol)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; normalize(:c)
:_c_

julia&gt; normalize(:_c)
:__c_

julia&gt; normalize(:_c_)
:_c_

julia&gt; normalize(:x_ijk)
:_x_ijk_

julia&gt; normalize(:x_ijk_)
:_x_ijk__

julia&gt; normalize(:_x_ijk_)
:_x_ijk_</code></pre><pre><code class="language-none">normalize(::Number)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; normalize(-1)
-1

julia&gt; normalize(0)
0

julia&gt; normalize(1)
1</code></pre><p>in</p><pre><code class="language-none">normalize(::Symbol, ::Integer)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; normalize(:x, 0)
:_x__0_

julia&gt; normalize(:x, 1)
:_x__1_

julia&gt; normalize(:x, -1)
:_x_m1_

julia&gt; normalize(:x, -100)
:_x_m100_

julia&gt; normalize(&quot;x&quot;, 0)
:_x__0_

julia&gt; normalize(&quot;x&quot;, 1)
:_x__1_

julia&gt; normalize(&quot;x&quot;, -1)
:_x_m1_

julia&gt; normalize(&quot;x&quot;, -100)
:_x_m100_</code></pre><pre><code class="language-none">normalize(::Tuple{Symbol,Integer})</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; normalize((:x, 0))
:_x__0_

julia&gt; normalize((:x, 1))
:_x__1_

julia&gt; normalize((:x, -1))
:_x_m1_

julia&gt; normalize((:x, -100))
:_x_m100_</code></pre><pre><code class="language-none">normalize(::Expr)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; normalize(:(a(1) - b - c(2) + d(-1)))
:(((_a__1_ - _b_) - _c__2_) + _d_m1_)

julia&gt; normalize(:(sin(x)))
:(sin(_x_))

julia&gt; normalize(:(sin(x(0))))
:(sin(_x__0_))

julia&gt; normalize(:(dot(x, y(1))))
:(dot(_x_, _y__1_))

julia&gt; normalize(:(beta * c(0)/c(1) * (alpha*y(1)/k(1) * (1-mu(1)) + 1 - delta_k) - 1))
:(((_beta_ * _c__0_) / _c__1_) * ((((_alpha_ * _y__1_) / _k__1_) * (1 - _mu__1_) + 1) - _delta_k_) - 1)

julia&gt; normalize(:(x = log(y(-1))); targets=[:x])  # with targets
:(_x_ = log(_y_m1_))

julia&gt; normalize(:(x = log(y(-1))))  # without targets
:(log(_y_m1_) - _x_)</code></pre><pre><code class="language-none">normalize(::String)</code></pre><p><strong>Examples</strong>: see above for more</p><pre><code class="language-julia-repl">julia&gt; normalize(&quot;x = log(y(-1))&quot;; targets=[:x])  # with targets
:(_x_ = log(_y_m1_))

julia&gt; normalize(&quot;x = log(y(-1))&quot;)  # without targets
:(log(_y_m1_) - _x_)</code></pre><pre><code class="language-none">normalize(::Vector{Expr})</code></pre><p><strong>Examples</strong>:</p><pre><code class="language-julia-repl">julia&gt; normalize([:(sin(x(0))), :(dot(x, y(1))), :(x = log(y(-1)))])
quote
    sin(_x__0_)
    dot(_x_, _y__1_)
    log(_y_m1_) - _x_
end

julia&gt; normalize([:(sin(x(0))), :(dot(x, y(1))), :(x = log(y(-1)))], targets=[:x])
quote
    sin(_x__0_)
    dot(_x_, _y__1_)
    _x_ = log(_y_m1_)
end</code></pre><h2><a class="nav-anchor" id="time_shift-1" href="#time_shift-1"><code>time_shift</code></a></h2><p><code>time_shift</code> shifts an expression by a specified number of time periods. As with normalize, there are many methods for this function, which will will describe one at a time.</p><pre><code class="language-none">time_shift(::Expr, ::Integer, ::Set{Symbol}, ::Associative)
time_shift(::Expr, ::Integer)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; defs = Dict(:a=&gt;:(b(-1)/c));

julia&gt; defs2 = Dict(:a=&gt;:(b(-1)/c(0)));

julia&gt; funcs = [:foobar];

julia&gt; shift = 1;

julia&gt; time_shift(:(a+b(1) + c), shift)
:(a + b(2) + c)

julia&gt; time_shift(:(a+b(1) + c(0)), shift)
:(a + b(2) + c(1))

julia&gt; time_shift(:(a+b(1) + c), shift, defs=defs)
:(b(0) / c + b(2) + c)

julia&gt; time_shift(:(a+b(1) + c(0)), shift, defs=defs)
:(b(0) / c + b(2) + c(1))

julia&gt; time_shift(:(a+b(1) + c(0)), shift, defs=defs2)
:(b(0) / c(1) + b(2) + c(1))

julia&gt; time_shift(:(a+b(1) + foobar(c)), shift, functions=funcs)
:(a + b(2) + foobar(c))

julia&gt; time_shift(:(a+b(1) + foobar(c)), shift, defs=defs, functions=funcs)
:(b(0) / c + b(2) + foobar(c))

julia&gt; shift = -1;

julia&gt; time_shift(:(a+b(1) + c), shift)
:(a + b(0) + c)

julia&gt; time_shift(:(a+b(1) + c(0)), shift)
:(a + b(0) + c(-1))

julia&gt; time_shift(:(a+b(1) + c), shift, defs=defs)
:(b(-2) / c + b(0) + c)

julia&gt; time_shift(:(a+b(1) + c(0)), shift, defs=defs)
:(b(-2) / c + b(0) + c(-1))

julia&gt; time_shift(:(a+b(1) + c(0)), shift, defs=defs2)
:(b(-2) / c(-1) + b(0) + c(-1))

julia&gt; time_shift(:(a+b(1) + foobar(c)), shift, functions=funcs)
:(a + b(0) + foobar(c))

julia&gt; time_shift(:(a+b(1) + foobar(c)), shift, defs=defs, functions=funcs)
:(b(-2) / c + b(0) + foobar(c))</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dolang.time_shift-Tuple{Symbol,Integer,Set{Symbol},Associative}" href="#Dolang.time_shift-Tuple{Symbol,Integer,Set{Symbol},Associative}"><code>Dolang.time_shift</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">time_shift(x::Number, other...)</code></pre><p>Return <code>x</code> for all values of <code>other</code></p></div><a class="source-link" target="_blank" href="https://github.com/EconForge/Dolang.jl/blob/d883ecfb3e14527d18db65442a5394d9a80a629a/src/symbolic.jl#L205-L209">source</a></section><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; defs = Dict(:a=&gt;:(b(-1)/c));

julia&gt; defs2 = Dict(:a=&gt;:(b(-1)/c(0)));

julia&gt; shift = 1;

julia&gt; funcs = Set([:foobar]);

julia&gt; time_shift(:a, shift, funcs, Dict())
:a

julia&gt; time_shift(:a, shift, funcs, defs)
:(b(0) / c)

julia&gt; time_shift(:a, shift, funcs, defs2)
:(b(0) / c(1))

julia&gt; time_shift(:b, shift, funcs, defs)
:b

julia&gt; shift = -1;

julia&gt; time_shift(:a, shift, funcs, Dict())
:a

julia&gt; time_shift(:a, shift, funcs, defs)
:(b(-2) / c)

julia&gt; time_shift(:a, shift, funcs, defs2)
:(b(-2) / c(-1))

julia&gt; time_shift(:b, shift, funcs, defs)
:b</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dolang.time_shift-Tuple{Number}" href="#Dolang.time_shift-Tuple{Number}"><code>Dolang.time_shift</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">time_shift(x::Number, other...)</code></pre><p>Return <code>x</code> for all values of <code>other</code></p></div><a class="source-link" target="_blank" href="https://github.com/EconForge/Dolang.jl/blob/d883ecfb3e14527d18db65442a5394d9a80a629a/src/symbolic.jl#L205-L209">source</a></section><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; time_shift(1)
1

julia&gt; time_shift(2)
2

julia&gt; time_shift(-1)
-1

julia&gt; time_shift(-2)
-2</code></pre><h2><a class="nav-anchor" id="steady_state-1" href="#steady_state-1"><code>steady_state</code></a></h2><p>The <code>steady_state</code> function will set the period for all &quot;timed&quot; variables to 0.</p><pre><code class="language-none">steady_state(::Symbol, ::Set{Symbol}, ::Associative)</code></pre><pre><code class="language-julia-repl">julia&gt; defs = Dict(:a=&gt;:(b(-1)/c + d), :d=&gt;:(exp(b(0))));

julia&gt; steady_state(:c, Set{Symbol}(), defs)
:c

julia&gt; steady_state(:d, Set{Symbol}(), defs)
:(exp(b))

julia&gt; steady_state(:a, Set{Symbol}(), defs)  # recursive def resolution
:(b / c + exp(b))

julia&gt; steady_state(1, Set{Symbol}(), defs)
1

julia&gt; steady_state(-1, Set{Symbol}(), defs)
-1</code></pre><p><strong>Examples</strong></p><pre><code class="language-none">steady_state(::Expr, ::Set{Symbol}, ::Associative)
steady_state(::Expr)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; steady_state(:(a+b(1) + c))
:(a + b + c)

julia&gt; steady_state(:(a+b(1) + c))
:(a + b + c)

julia&gt; steady_state(:(a+b(1) + c), defs=Dict(:a=&gt;:(b(-1)/c)))
:(b / c + b + c)

julia&gt; steady_state(:(a+b(1)+c+foobar(c)))
ERROR: Dolang.UnknownFunctionError(:foobar, &quot;Unknown function foobar&quot;)

julia&gt; steady_state(:(a+b(1) + foobar(c)), functions=[:foobar])
:(a + b + foobar(c))</code></pre><h2><a class="nav-anchor" id="list_symbols-1" href="#list_symbols-1"><code>list_symbols</code></a></h2><p><code>list_symbols</code> will walk an expression and determine which symbols are used as potentially time varying <em>variables</em> and which symbols are used as static <em>parameters</em>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dolang.list_symbols!-Tuple{Any,Expr,Set{Symbol}}" href="#Dolang.list_symbols!-Tuple{Any,Expr,Set{Symbol}}"><code>Dolang.list_symbols!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">list_symbols!(out, s::Expr, functions::Set{Symbol})</code></pre><p>Walk the expression and populate <code>out</code> according to the following rules for each type of subexpression encoutered:</p><ul><li><p><code>s::Symbol</code>: add <code>s</code> to <code>out[:parameters]</code></p></li><li><p><code>x(i::Integer)</code>: Add <code>(x, i)</code> out <code>out[:variables]</code></p></li><li><p>All other function calls: add any arguments to <code>out</code> according to above rules</p></li><li><p>Anything else: do nothing.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/EconForge/Dolang.jl/blob/d883ecfb3e14527d18db65442a5394d9a80a629a/src/symbolic.jl#L375-L385">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dolang.list_symbols-Tuple{Expr}" href="#Dolang.list_symbols-Tuple{Expr}"><code>Dolang.list_symbols</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">list_symbols(::Expr;
             functions::Union{Set{Symbol},Vector{Symbol}}=Set{Symbol}())</code></pre><p>Construct an empty <code>Dict{Symbol,Any}</code> and call <code>list_symbols!</code> to populate it</p></div><a class="source-link" target="_blank" href="https://github.com/EconForge/Dolang.jl/blob/d883ecfb3e14527d18db65442a5394d9a80a629a/src/symbolic.jl#L343-L348">source</a></section><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; list_symbols(:(a + b(1) + c))
Dict{Symbol,Any} with 2 entries:
  :variables  =&gt; Set(Tuple{Symbol,Int64}[(:b, 1)])
  :parameters =&gt; Set(Symbol[:a, :c])

julia&gt; list_symbols(:(a + b(1) + c + b(0)))
Dict{Symbol,Any} with 2 entries:
  :variables  =&gt; Set(Tuple{Symbol,Int64}[(:b, 1), (:b, 0)])
  :parameters =&gt; Set(Symbol[:a, :c])

julia&gt; list_symbols(:(a + b(1) + c + b(0) + foobar(x)))
ERROR: Dolang.UnknownFunctionError(:foobar, &quot;Unknown function foobar&quot;)

julia&gt; list_symbols(:(a + b(1) + c + b(0) + foobar(x)), functions=Set([:foobar]))
Dict{Symbol,Any} with 2 entries:
  :variables  =&gt; Set(Tuple{Symbol,Int64}[(:b, 1), (:b, 0)])
  :parameters =&gt; Set(Symbol[:a, :c, :x])</code></pre><h2><a class="nav-anchor" id="list_variables-1" href="#list_variables-1"><code>list_variables</code></a></h2><p><code>list_variables</code> will return the <code>:variables</code> key that results from calling <code>list_symbols</code>. The type of the returned object will be a <code>Set</code> of <code>Tuple{Symbol,Int}</code>, where each item describes the symbol that appeared and the corresponding date.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dolang.list_variables-Tuple{Any}" href="#Dolang.list_variables-Tuple{Any}"><code>Dolang.list_variables</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">list_variables(
    arg;
    functions::Union{Set{Symbol},Vector{Symbol}}=Set{Symbol}()
)</code></pre><p>Return the <code>:variables</code> key that results from calling <code>list_symbols</code>. The type of the returned object will be a <code>Set</code> of <code>Tuple{Symbol,Int}</code>, where each item describes the symbol that appeared and the corresponding date.</p></div><a class="source-link" target="_blank" href="https://github.com/EconForge/Dolang.jl/blob/d883ecfb3e14527d18db65442a5394d9a80a629a/src/symbolic.jl#L418-L427">source</a></section><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; list_variables(:(a + b(1) + c))
Set(Tuple{Symbol,Int64}[(:b, 1)])

julia&gt; list_variables(:(a + b(1) + c + b(0)))
Set(Tuple{Symbol,Int64}[(:b, 1), (:b, 0)])

julia&gt; list_variables(:(a + b(1) + c + b(0) + foobar(x)))
ERROR: Dolang.UnknownFunctionError(:foobar, &quot;Unknown function foobar&quot;)

julia&gt; list_variables(:(a + b(1) + c + b(0) + foobar(x)), functions=Set([:foobar]))
Set(Tuple{Symbol,Int64}[(:b, 1), (:b, 0)])</code></pre><h2><a class="nav-anchor" id="list_parameters-1" href="#list_parameters-1"><code>list_parameters</code></a></h2><p><code>list_parameters</code> will return the <code>:parameters</code> key that results from calling <code>list_symbols</code>. The returned object will be <code>Set{Symbol}</code> where each item represents the symbol that appeared without a date.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dolang.list_parameters-Tuple{Any}" href="#Dolang.list_parameters-Tuple{Any}"><code>Dolang.list_parameters</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">list_parameters(
    arg;
    functions::Union{Set{Symbol},Vector{Symbol}}=Set{Symbol}()
)</code></pre><p>Return the <code>:parameters</code> key that results from calling <code>list_symbols</code>. The returned object will be <code>Set{Symbol}</code> where each item represents the symbol that appeared without a date.</p></div><a class="source-link" target="_blank" href="https://github.com/EconForge/Dolang.jl/blob/d883ecfb3e14527d18db65442a5394d9a80a629a/src/symbolic.jl#L435-L444">source</a></section><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; list_variables(:(a + b(1) + c + b(0) + foobar(x)), functions=Set([:foobar]))
Set(Tuple{Symbol,Int64}[(:b, 1), (:b, 0)])

julia&gt; list_parameters(:(a + b(1) + c))
Set(Symbol[:a, :c])

julia&gt; list_parameters(:(a + b(1) + c + b(0)))
Set(Symbol[:a, :c])

julia&gt; list_parameters(:(a + b(1) + c + b(0) + foobar(x)))
ERROR: Dolang.UnknownFunctionError(:foobar, &quot;Unknown function foobar&quot;)

julia&gt; list_parameters(:(a + b(1) + c + b(0) + foobar(x)), functions=Set([:foobar]))
Set(Symbol[:a, :c, :x])</code></pre><h2><a class="nav-anchor" id="subs-1" href="#subs-1"><code>subs</code></a></h2><p><code>subs</code> will replace a symbol or expression with a different value, where the value has type <code>Union{Symbol,Expr,Number}</code></p><p>The first method of this function is very specific, and matches only a particular pattern:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dolang.subs-Tuple{Union{Expr, Number, Symbol},Any,Union{Expr, Number, Symbol},Set{Symbol}}" href="#Dolang.subs-Tuple{Union{Expr, Number, Symbol},Any,Union{Expr, Number, Symbol},Set{Symbol}}"><code>Dolang.subs</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">subs(ex::Union{Expr,Symbol,Number}, from, to::Union{Symbol,Expr,Number}, funcs::Set{Symbol})</code></pre><p>Apply a substitution where all occurances of <code>from</code> in <code>ex</code> are replaced by <code>to</code>.</p><p>Note that to replace something like <code>x(1)</code> <code>from</code> must be the canonical form for that expression: <code>(:x, 1)</code></p></div><a class="source-link" target="_blank" href="https://github.com/EconForge/Dolang.jl/blob/d883ecfb3e14527d18db65442a5394d9a80a629a/src/symbolic.jl#L502-L511">source</a></section><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; subs(:(a + b(1) + c), :a, :(b(-1)/c + d), Set{Symbol}())
:((b(-1) / c + d) + b(1) + c)

julia&gt; subs(:(a + b(1) + c), :d, :(b(-1)/c + d), Set{Symbol}())
:(a + b(1) + c)</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dolang.subs-Tuple{Expr,Associative,Set{Symbol}}" href="#Dolang.subs-Tuple{Expr,Associative,Set{Symbol}}"><code>Dolang.subs</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">subs(ex::Union{Expr,Symbol,Number}, d::Associative,
     variables::Set{Symbol},
     funcs::Set{Symbol})</code></pre><p>Apply substitutions to <code>ex</code> so that all keys in <code>d</code> are replaced by their values</p><p>Note that the keys of <code>d</code> should be the canonical form of variables you wish to substitute. For example, to replace <code>x(1)</code> with <code>b/c</code> you need to have the entry <code>(:x, 1) =&gt; :(b/c)</code> in <code>d</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/EconForge/Dolang.jl/blob/d883ecfb3e14527d18db65442a5394d9a80a629a/src/symbolic.jl#L518-L530">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dolang.subs-Tuple{Expr,Associative}" href="#Dolang.subs-Tuple{Expr,Associative}"><code>Dolang.subs</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">subs(ex::Union{Expr,Symbol,Number}, d::Associative,
     variables::Set{Symbol},
     funcs::Set{Symbol})</code></pre><p>Apply substitutions to <code>ex</code> so that all keys in <code>d</code> are replaced by their values</p><p>Note that the keys of <code>d</code> should be the canonical form of variables you wish to substitute. For example, to replace <code>x(1)</code> with <code>b/c</code> you need to have the entry <code>(:x, 1) =&gt; :(b/c)</code> in <code>d</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/EconForge/Dolang.jl/blob/d883ecfb3e14527d18db65442a5394d9a80a629a/src/symbolic.jl#L518-L530">source</a></section><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ex = :(a + b);

julia&gt; d = Dict(:b =&gt; :(c/a), :c =&gt; :(2a));

julia&gt; subs(ex, d)  # subs is not recursive -- c is not replaced
:(a + c / a)</code></pre><h2><a class="nav-anchor" id="csubs-1" href="#csubs-1"><code>csubs</code></a></h2><p><code>csubs</code> is closely related to <code>subs</code>, but is more Clever and applies substitutions recursively.</p><pre><code class="language-none">csubs(::Expr, ::Associative, ::Set{Symbol})
csubs(::Expr, ::Associative)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ex = :(a + b);

julia&gt; d = Dict(:b =&gt; :(c/a), :c =&gt; :(2a));

julia&gt; csubs(ex, d)  # csubs is recursive -- c is replaced
:(a + (2a) / a)

julia&gt; d1 = Dict(:monty=&gt; :python, :run=&gt;:faster, :eat=&gt;:more);

julia&gt; csubs(:(monty(run + eat, eat)), d1)
:(python(faster + more, more))

julia&gt; csubs(:(a + b(0) + b(1)), Dict(:b =&gt; :(c(0) + d(1))))
:(a + (c(0) + d(1)) + (c(1) + d(2)))

julia&gt; csubs(:(a + b(0) + b(1)), Dict((:b, 1) =&gt; :(c(0) + d(1))))
:(a + b(0) + (c(0) + d(1)))

julia&gt; csubs(:(a + b(0) + b(1)), Dict(:b =&gt; :(c + d(1))))
:(a + (c + d(1)) + (c + d(2)))

julia&gt; csubs(:(a + b(0) + b(1)), Dict((:b, 1) =&gt; :(c + d(1))))
:(a + b(0) + (c + d(1)))

julia&gt; d = Dict((:b, 0) =&gt; :(c + d(1)), (:b, 1) =&gt; :(c(100) + d(2)));

julia&gt; csubs(:(a + b + b(1)), d)
:(a + (c + d(1)) + (c(100) + d(2)))</code></pre><footer><hr/><a class="previous" href="index.html"><span class="direction">Previous</span><span class="title">Dolang.jl</span></a><a class="next" href="compiler.html"><span class="direction">Next</span><span class="title">Dolang&#39;s compiler</span></a></footer></article></body></html>
