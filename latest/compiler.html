<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Dolang&#39;s compiler · Dolang.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Dolang.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><span class="toctext">Guide</span><ul><li><a class="toctext" href="index.html">Dolang.jl</a></li><li><a class="toctext" href="symbolic.html">Symbolic manipulation</a></li><li class="current"><a class="toctext" href="compiler.html">Dolang&#39;s compiler</a><ul class="internal"><li><a class="toctext" href="#FunctionFactory-1"><code>FunctionFactory</code></a></li><li><a class="toctext" href="#make_function-1"><code>make_function</code></a></li></ul></li><li><a class="toctext" href="examples.html">Examples</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="dev/compiler.html">Compiler internals</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Guide</li><li><a href="compiler.html">Dolang&#39;s compiler</a></li></ul><a class="edit-page" href="https://github.com/EconForge/Dolang.jl/blob/master/docs/src/compiler.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Dolang&#39;s compiler</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Dolang&#39;s-compiler-1" href="#Dolang&#39;s-compiler-1">Dolang&#39;s compiler</a></h1><p>The second main component of Dolang is a compiler that leverages its <a href="symbolic.html#Symbolic-manipulation-1">Symbolic manipulation</a> routines to produce efficient Julia functions to evaluate equations and systems of equations.</p><h2><a class="nav-anchor" id="FunctionFactory-1" href="#FunctionFactory-1"><code>FunctionFactory</code></a></h2><p>The compiler mainly operates through one main type, the <code>FunctionFactory</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dolang.FunctionFactory" href="#Dolang.FunctionFactory"><code>Dolang.FunctionFactory</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">FunctionFactory{T4}([dispatch::Type{T4}], eqs::Vector{Expr},
                     args::ArgType, params::ParamType; targets=Symbol[],
                     defs=Dict{Symbol,Any}(), funname::Symbol=:anon)</code></pre><p>Construct a <code>FunctionFactory</code> that evaluates <code>eqs</code> using <code>args</code> and <code>params</code>.</p><p><code>args</code> and <code>params</code> can either be flat <code>Vector</code> of Dolang symbols (not just julia <code>Symbols</code>), or an associative mapping from a grouped argument name, to a list of symbols in that group. See examples below:</p><pre><code class="language-julia"># if ...
args = Dict(:x =&gt; [(:a, 0), (:b, 0)], :X =&gt; [(:a, 1)])
params = [:beta, :delta]

# compiled function would have arguments ...
# funname(..., x, X, p)
# where length(x) = 2, length(X) = 1, length(p) = 2</code></pre><pre><code class="language-julia"># if ...
args = [(:a, 0), (:b, 0), (:a, 1)]
params = [:beta, :delta]

# compiled function would have arguments ...
# funname(..., V, p)
# where length(V) = 3, length(p) = 2</code></pre><p>Optional function arguments have the following purposes:</p><ul><li><p><code>funname</code>: instruct the Dolang compiler that the compiled function should have a particular name</p></li><li><p><code>targets</code>: If non-empty and the symbols listed in <code>targets</code> and <code>eqs</code> contains statements of the form <code>lhs = rhs</code> –</p></li><li><p><code>defs</code>: Recursively substitute definitions into <code>eqs</code> (see <a href="@ref"><code>csubs</code></a> for more info)</p></li><li><p><code>dispatch</code>: If this argument is passed, then the Dolang compiler will generate code for a function whose first argument must be an instance of type <code>T4</code>. This can be used to compile functions with the same <code>funname</code>, but different behavior based on the type of <code>dispatch</code>. Note that the argument to <code>FunctionFactory</code> must be the name of a type, not an instance of a type (e.g. <code>Float64</code> instead of <code>1.0</code>), but when calling the compiled code you must pass an instance instead of the name of the type (e.g. <code>funname(1.0, ...)</code> not <code>funname(Float64, ...)</code>)</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/EconForge/Dolang.jl/blob/a2e18702e0dcb6b600c393f6d0fc8650d1b20d88/src/factory.jl#L210-L257">source</a></section><h2><a class="nav-anchor" id="make_function-1" href="#make_function-1"><code>make_function</code></a></h2><p>Once an instance of <code>FunctionFactory</code> is created, a single function is used to compile Julia a function with various methods for evaluating different orders of derivative of the factory&#39;s expressions. This function is named <code>make_function</code> and is called</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dolang.make_function-Tuple{Dolang.FunctionFactory}" href="#Dolang.make_function-Tuple{Dolang.FunctionFactory}"><code>Dolang.make_function</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">make_function(ff::FunctionFactory)</code></pre><p>Compile a function using data in <code>ff</code>; with methods for</p><ul><li><p>various order of derivative</p></li><li><p>Allocating output arguments</p></li><li><p>Non-allocating functions that mutate the input argument</p></li><li><p>(partially-)Vectorized evaluation</p></li></ul><p>See <a href="compiler.html#Dolang.FunctionFactory"><code>FunctionFactory</code></a> for a description of how the fields of <code>ff</code> impact the generated code.</p><p>In non-vectorized evaluation, all function arguments should be vectors and will be unpacked into scalars according to <code>ff.args</code> and <code>ff.params</code>. If any argument is an  <code>AbstractMatrix</code>, then each column of the matrix is assumed to be multiple observations of a single variable. All matrix arguments must have the same number of rows. Let this number be <code>n</code>. Any arguments passed as vectors will be implicitly repeated <code>n</code> times and the function will be evaluated with these vectors and the <code>n</code> observations of each matrix argument.</p><p><strong>Note</strong></p><p>The output will be an <code>@generated</code> function that can be evaluated at arbitrary order of analytical derivative – with derivative computation and function compilation happening at runtime upon the user&#39;s first request to evaluate that order derivative.</p></div><a class="source-link" target="_blank" href="https://github.com/EconForge/Dolang.jl/blob/a2e18702e0dcb6b600c393f6d0fc8650d1b20d88/src/compiler.jl#L718-L745">source</a></section><p>There is also a convenience method of <code>make_function</code> that takes built-in Julia objects as inputs, constructs the <code>FunctionFactory</code> for you, then calls the above method:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dolang.make_function-Tuple{Array{Expr,1},AbstractArray{T,1} where T,AbstractArray{T,1} where T}" href="#Dolang.make_function-Tuple{Array{Expr,1},AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>Dolang.make_function</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">make_function(
    eqs::Vector{Expr}, variables::AbstractVector,
    to_diff::AbstractVector=1:length(variables);
    dispatch::DataType=SkipArg,
    targets=Symbol[], name::Symbol=:anon,
    defs=Dict()
)</code></pre><p>Compile a Julia function by first constructing a <code>FunctionFactory</code> instance where</p><ul><li><p><code>args</code> is equal to <code>variables[to_diff]</code></p></li><li><p><code>params</code> is equal to <code>variables[setdiff(to_diff, 1:length(variables))]</code></p></li><li><p><code>eqs</code>, <code>dispatch</code>, <code>defs</code>, <code>targets</code>, and <code>name</code> are passed along to the <code>FunctionFactory</code> as arguments with the same name (except <code>name</code>, which becomes the <code>funname</code> argument to <code>FunctionFactory</code>)</p></li></ul><p>See <a href="compiler.html#Dolang.make_function-Tuple{Dolang.FunctionFactory}"><code>make_function(ff::FunctionFactory)</code></a> for more details.</p><p>This method is less flexible than constructing the <code>FunctionFactory</code> by hand because you can only create that have one vector for arguments and one vector for symbols. Meaning you cannot construct an associative mapping for <code>args</code> or <code>params</code> that groups symbols together.</p></div><a class="source-link" target="_blank" href="https://github.com/EconForge/Dolang.jl/blob/a2e18702e0dcb6b600c393f6d0fc8650d1b20d88/src/compiler.jl#L666-L690">source</a></section><footer><hr/><a class="previous" href="symbolic.html"><span class="direction">Previous</span><span class="title">Symbolic manipulation</span></a><a class="next" href="examples.html"><span class="direction">Next</span><span class="title">Examples</span></a></footer></article></body></html>
