<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · Dolang.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Dolang.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><span class="toctext">Guide</span><ul><li><a class="toctext" href="index.html">Dolang.jl</a></li><li><a class="toctext" href="symbolic.html">Symbolic manipulation</a></li><li><a class="toctext" href="compiler.html">Dolang&#39;s compiler</a></li><li class="current"><a class="toctext" href="examples.html">Examples</a><ul class="internal"><li><a class="toctext" href="#Basic-example-1">Basic example</a></li><li><a class="toctext" href="#With-dispatch-1">With <code>dispatch</code></a></li><li><a class="toctext" href="#With-grouped-args-1">With grouped <code>args</code></a></li></ul></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="dev/compiler.html">Compiler internals</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Guide</li><li><a href="examples.html">Examples</a></li></ul><a class="edit-page" href="https://github.com/EconForge/Dolang.jl/tree/a15b4bea5e0fda38a02f76e250ece22e9f5a88a9/docs/src/examples.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Examples</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Examples-1" href="#Examples-1">Examples</a></h1><p>Let&#39;s show some examples of how use Dolang to compile simple Julia functions.</p><h2><a class="nav-anchor" id="Basic-example-1" href="#Basic-example-1">Basic example</a></h2><p>First, let&#39;s construct some equations, arguments, and parameters</p><div><pre><code class="language-julia">using Dolang
eqs = [
    :(foo(0) = log(a(0))+b(0)/x(-1)),
    :(bar(0) = c(1)+u*d(1))
]
args = [(:a, -1), (:a, 0), (:b, 0), (:c, 0), (:c, 1), (:d, 1)]
params = [:u]
defs = Dict(:x=&gt;:(a(0)/(1-c(1))))
targets = [(:foo, 0), (:bar, 0)]

ff = FunctionFactory(
    eqs, args, params, targets=targets, defs=defs, funname=:myfun
)</code></pre><pre><code class="language-none">FunctionFactory
            name: myfun
  # of equations: 2
       # of args: 6
     # of params: 1
    Has targets?: true</code></pre></div><p>Now that we have our <code>FunctionFactory</code> we can generate some code (warning, the generated code is <em>not</em> pretty):</p><div><pre><code class="language-julia">code = make_function(ff)</code></pre><pre><code class="language-none">begin
    @generated function myfun{D}(::Dolang.TDer{D}, V::AbstractVector, p)
            ff = Dolang.FunctionFactory{Array{Tuple{Symbol,Int64},1},Array{Symbol,1},Dict{Symbol,Expr},DataType}(Expr[:(_foo__0_ = log(_a__0_) + _b__0_ / (_a_m1_ / (1 - _c__0_))), :(_bar__0_ = _c__1_ + _u_ * _d__1_)], Tuple{Symbol,Int64}[(:a, -1), (:a, 0), (:b, 0), (:c, 0), (:c, 1), (:d, 1)], Symbol[:u], Symbol[:_foo__0_, :_bar__0_], Dict(:x=&gt;:(a(0) / (1 - c(1)))), :myfun, Dolang.SkipArg, Dolang.IncidenceTable(Dict(2=&gt;Dict(:d=&gt;Set([1]),:bar=&gt;Set([0]),:c=&gt;Set([1])),1=&gt;Dict(:a=&gt;Set([0, -1]),:b=&gt;Set([0]),:c=&gt;Set([0]),:foo=&gt;Set([0]),:x=&gt;Set([-1]))), Dict(:a=&gt;Set([0, -1]),:b=&gt;Set([0]),:d=&gt;Set([1]),:bar=&gt;Set([0]),:c=&gt;Set([0, 1]),:foo=&gt;Set([0]),:x=&gt;Set([-1])), Dict(0=&gt;Set(Symbol[:a, :b, :bar, :c, :foo]),-1=&gt;Set(Symbol[:a, :x]),1=&gt;Set(Symbol[:d, :c]))))
            Dolang.func_body(ff, Der{D})
        end
    @generated function myfun!{D}(::Dolang.TDer{D}, out, V::AbstractVector, p)
            ff = Dolang.FunctionFactory{Array{Tuple{Symbol,Int64},1},Array{Symbol,1},Dict{Symbol,Expr},DataType}(Expr[:(_foo__0_ = log(_a__0_) + _b__0_ / (_a_m1_ / (1 - _c__0_))), :(_bar__0_ = _c__1_ + _u_ * _d__1_)], Tuple{Symbol,Int64}[(:a, -1), (:a, 0), (:b, 0), (:c, 0), (:c, 1), (:d, 1)], Symbol[:u], Symbol[:_foo__0_, :_bar__0_], Dict(:x=&gt;:(a(0) / (1 - c(1)))), :myfun, Dolang.SkipArg, Dolang.IncidenceTable(Dict(2=&gt;Dict(:d=&gt;Set([1]),:bar=&gt;Set([0]),:c=&gt;Set([1])),1=&gt;Dict(:a=&gt;Set([0, -1]),:b=&gt;Set([0]),:c=&gt;Set([0]),:foo=&gt;Set([0]),:x=&gt;Set([-1]))), Dict(:a=&gt;Set([0, -1]),:b=&gt;Set([0]),:d=&gt;Set([1]),:bar=&gt;Set([0]),:c=&gt;Set([0, 1]),:foo=&gt;Set([0]),:x=&gt;Set([-1])), Dict(0=&gt;Set(Symbol[:a, :b, :bar, :c, :foo]),-1=&gt;Set(Symbol[:a, :x]),1=&gt;Set(Symbol[:d, :c]))))
            Dolang.func_body!(ff, Der{D})
        end
    @generated function myfun(::Dolang.TDer{0}, V::AbstractVector, p)
            ff = Dolang.FunctionFactory{Array{Tuple{Symbol,Int64},1},Array{Symbol,1},Dict{Symbol,Expr},DataType}(Expr[:(_foo__0_ = log(_a__0_) + _b__0_ / (_a_m1_ / (1 - _c__0_))), :(_bar__0_ = _c__1_ + _u_ * _d__1_)], Tuple{Symbol,Int64}[(:a, -1), (:a, 0), (:b, 0), (:c, 0), (:c, 1), (:d, 1)], Symbol[:u], Symbol[:_foo__0_, :_bar__0_], Dict(:x=&gt;:(a(0) / (1 - c(1)))), :myfun, Dolang.SkipArg, Dolang.IncidenceTable(Dict(2=&gt;Dict(:d=&gt;Set([1]),:bar=&gt;Set([0]),:c=&gt;Set([1])),1=&gt;Dict(:a=&gt;Set([0, -1]),:b=&gt;Set([0]),:c=&gt;Set([0]),:foo=&gt;Set([0]),:x=&gt;Set([-1]))), Dict(:a=&gt;Set([0, -1]),:b=&gt;Set([0]),:d=&gt;Set([1]),:bar=&gt;Set([0]),:c=&gt;Set([0, 1]),:foo=&gt;Set([0]),:x=&gt;Set([-1])), Dict(0=&gt;Set(Symbol[:a, :b, :bar, :c, :foo]),-1=&gt;Set(Symbol[:a, :x]),1=&gt;Set(Symbol[:d, :c]))))
            Dolang.func_body(ff, Der{0})
        end
    @generated function myfun!(::Dolang.TDer{0}, out, V::AbstractVector, p)
            ff = Dolang.FunctionFactory{Array{Tuple{Symbol,Int64},1},Array{Symbol,1},Dict{Symbol,Expr},DataType}(Expr[:(_foo__0_ = log(_a__0_) + _b__0_ / (_a_m1_ / (1 - _c__0_))), :(_bar__0_ = _c__1_ + _u_ * _d__1_)], Tuple{Symbol,Int64}[(:a, -1), (:a, 0), (:b, 0), (:c, 0), (:c, 1), (:d, 1)], Symbol[:u], Symbol[:_foo__0_, :_bar__0_], Dict(:x=&gt;:(a(0) / (1 - c(1)))), :myfun, Dolang.SkipArg, Dolang.IncidenceTable(Dict(2=&gt;Dict(:d=&gt;Set([1]),:bar=&gt;Set([0]),:c=&gt;Set([1])),1=&gt;Dict(:a=&gt;Set([0, -1]),:b=&gt;Set([0]),:c=&gt;Set([0]),:foo=&gt;Set([0]),:x=&gt;Set([-1]))), Dict(:a=&gt;Set([0, -1]),:b=&gt;Set([0]),:d=&gt;Set([1]),:bar=&gt;Set([0]),:c=&gt;Set([0, 1]),:foo=&gt;Set([0]),:x=&gt;Set([-1])), Dict(0=&gt;Set(Symbol[:a, :b, :bar, :c, :foo]),-1=&gt;Set(Symbol[:a, :x]),1=&gt;Set(Symbol[:d, :c]))))
            Dolang.func_body!(ff, Der{0})
        end
    function myfun(V::AbstractVector, p)
        myfun(Dolang.Der{0}, V::AbstractVector, p)
    end
    function myfun!(out, V::AbstractVector, p)
        myfun!(Dolang.Der{0}, out, V::AbstractVector, p)
    end
    begin
        function myfun(::Dolang.TDer{0}, V::AbstractArray, p)
            out = Dolang._allocate_out(eltype(V), 2, V)
            begin
                nrow = size(out, 1)
                for _row = 1:nrow
                    __out__row = view(out, _row, :)
                    __V__row = Dolang._unpack_obs(V, _row)
                    myfun!(Dolang.Der{0}, __out__row, __V__row, p)
                end
                return out
            end
        end
        function myfun(V::AbstractArray, p)
            out = Dolang._allocate_out(eltype(V), 2, V)
            begin
                nrow = size(out, 1)
                for _row = 1:nrow
                    __out__row = view(out, _row, :)
                    __V__row = Dolang._unpack_obs(V, _row)
                    myfun!(Dolang.Der{0}, __out__row, __V__row, p)
                end
                return out
            end
        end
    end
    begin
        function myfun!(::Dolang.TDer{0}, out, V::AbstractArray, p)
            begin
                expected_size = Dolang._output_size(2, V)
                if size(out) != expected_size
                    msg = &quot;Expected out to be size $(expected_size), found $(size(out))&quot;
                    throw(DimensionMismatch(msg))
                end
            end
            begin
                nrow = size(out, 1)
                for _row = 1:nrow
                    __out__row = view(out, _row, :)
                    __V__row = Dolang._unpack_obs(V, _row)
                    myfun!(Dolang.Der{0}, __out__row, __V__row, p)
                end
                return out
            end
        end
        function myfun!(out, V::AbstractArray, p)
            begin
                expected_size = Dolang._output_size(2, V)
                if size(out) != expected_size
                    msg = &quot;Expected out to be size $(expected_size), found $(size(out))&quot;
                    throw(DimensionMismatch(msg))
                end
            end
            begin
                nrow = size(out, 1)
                for _row = 1:nrow
                    __out__row = view(out, _row, :)
                    __V__row = Dolang._unpack_obs(V, _row)
                    myfun!(Dolang.Der{0}, __out__row, __V__row, p)
                end
                return out
            end
        end
    end
    (myfun, myfun!)
end</code></pre></div><p>In order to actually call methods of <code>myfun</code> we need to call <code>eval</code> on our <code>code</code>:</p><div><pre><code class="language-julia">eval(code)</code></pre><pre><code class="language-none">(myfun, myfun!)</code></pre></div><p>And now we can call it</p><div><pre><code class="language-julia">V = [1.5, 2.5, 1.0, 2.0, 3.0, 1.1]
p = [0.5]
myfun(V, p)</code></pre><pre><code class="language-none">2-element Array{Float64,1}:
 0.249624
 3.55</code></pre></div><p>We can call the vectorized version:</p><div><pre><code class="language-julia">myfun([V V]&#39;, p)</code></pre><pre><code class="language-none">2×2 Array{Float64,2}:
 0.249624  3.55
 0.249624  3.55</code></pre></div><p>Or the mutating one:</p><div><pre><code class="language-julia">out = zeros(2)
myfun!(out, V, p)
out</code></pre><pre><code class="language-none">2-element Array{Float64,1}:
 0.249624
 3.55</code></pre></div><p>We can evaluate the Jacobian (first derivative matrix)</p><div><pre><code class="language-julia">myfun(Der{1}, V, p)</code></pre><pre><code class="language-none">2×6 Array{Float64,2}:
 0.444444  0.4  -0.666667  -0.666667  0.0  0.0
 0.0       0.0   0.0        0.0       1.0  0.5</code></pre></div><p>... or the Hessian</p><div><pre><code class="language-julia">myfun(Der{2}, V, p)</code></pre><pre><code class="language-none">2×36 SparseMatrixCSC{Float64,Int64} with 8 stored entries:
  [1 ,  1]  =  -0.592593
  [1 ,  3]  =  0.444444
  [1 ,  4]  =  0.444444
  [1 ,  8]  =  -0.16
  [1 , 13]  =  0.444444
  [1 , 16]  =  -0.666667
  [1 , 19]  =  0.444444
  [1 , 21]  =  -0.666667</code></pre></div><p>... or higher order derivatives</p><div><pre><code class="language-julia">myfun(Der{3}, V, p)</code></pre><pre><code class="language-none">2-element Array{Dict{Tuple{Int64,Int64,Int64},Float64},1}:
 Dict((1, 1, 3)=&gt;-0.592593,(1, 1, 1)=&gt;1.18519,(2, 2, 2)=&gt;0.128,(1, 1, 4)=&gt;-0.592593,(1, 3, 4)=&gt;0.444444)
 Dict{Tuple{Int64,Int64,Int64},Float64}()</code></pre></div><div><pre><code class="language-julia">myfun(Der{10}, V, p)</code></pre><pre><code class="language-none">2-element Array{Dict{NTuple{10,Int64},Float64},1}:
 Dict((2, 2, 2, 2, 2, 2, 2, 2, 2, 2)=&gt;-38.0507,(1, 1, 1, 1, 1, 1, 1, 1, 1, 3)=&gt;6292.89,(1, 1, 1, 1, 1, 1, 1, 1, 1, 4)=&gt;6292.89,(1, 1, 1, 1, 1, 1, 1, 1, 1, 1)=&gt;-41952.6,(1, 1, 1, 1, 1, 1, 1, 1, 3, 4)=&gt;-1048.82)
 Dict{NTuple{10,Int64},Float64}()</code></pre></div><p>Note that the Hessian is returned in as a <code>SparseMatrixCSC</code> where the columns are ordered with the first variable increasing faster. In this example, the <code>(1, 4)</code> element of the Hessian will be the second partial derivative of the first equation (the <code>1</code>) with fourth and first variables in <code>args</code>.</p><p>For all higher order derivatives the return value is a <code>Vector{Dict{NTuple{N,Int}, Float64}}</code>, where <code>N</code> is the order of derivative. The keys of each dict will be non-increasing so mixed partials are only computed and stored once. Notice that for the order <code>3</code> derivatives an entry for <code>(1, 1, 3)</code> appears, but not for <code>(1, 3, 1)</code> or <code>(3, 1, 1)</code>. The user of these routines is required to handle the <a href="https://calculus.subwiki.org/wiki/Clairaut%27s_theorem_on_equality_of_mixed_partials">equality of partials</a>.</p><h2><a class="nav-anchor" id="With-dispatch-1" href="#With-dispatch-1">With <code>dispatch</code></a></h2><p>Now lets consider an example that leverages the <code>dispatch</code> argument. In this case we will use the convenience method for make function with signature: <a href="compiler.html#Dolang.make_function-Tuple{Array{Expr,1},AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>make_function(::Vector{Expr}, ::AbstractVector, ::AbstractVector)</code></a>. We also will not show the compiled code</p><div><pre><code class="language-julia">eqs = [
    :(sin(x(0)) + exp(2*x(1))),
    :(y(0) / (2 * (1 - β))),
]
# NOTE: Arguments can be pre-normalized and contain unicode
variables = [(:x, 0), (:y, 0), :_x__1_, :β]
to_diff = 1:3
code = make_function(eqs, variables, to_diff, dispatch=Int, name=:my_int_fun)
eval(code)</code></pre><pre><code class="language-none">(my_int_fun, my_int_fun!)</code></pre></div><p>Let&#39;s check the methods of <code>my_int_fun</code> and <code>my_int_fun!</code>:</p><div><pre><code class="language-julia">methods(my_int_fun)</code></pre><pre><code class="language-none"># 5 methods for generic function &quot;my_int_fun&quot;:
my_int_fun(::Type{Dolang.Der{0}}, dispatch::Int64, V::AbstractArray{T,1} where T, p) in ex-ff2
my_int_fun(::Type{Dolang.Der{D}}, dispatch::Int64, V::AbstractArray{T,1} where T, p) where D in ex-ff2
my_int_fun(dispatch::Int64, V::AbstractArray{T,1} where T, p) in ex-ff2
my_int_fun(::Type{Dolang.Der{0}}, dispatch::Int64, V::AbstractArray, p) in ex-ff2
my_int_fun(dispatch::Int64, V::AbstractArray, p) in ex-ff2</code></pre></div><div><pre><code class="language-julia">methods(my_int_fun!)</code></pre><pre><code class="language-none"># 5 methods for generic function &quot;my_int_fun!&quot;:
my_int_fun!(::Type{Dolang.Der{0}}, dispatch::Int64, out, V::AbstractArray{T,1} where T, p) in ex-ff2
my_int_fun!(::Type{Dolang.Der{D}}, dispatch::Int64, out, V::AbstractArray{T,1} where T, p) where D in ex-ff2
my_int_fun!(dispatch::Int64, out, V::AbstractArray{T,1} where T, p) in ex-ff2
my_int_fun!(::Type{Dolang.Der{0}}, dispatch::Int64, out, V::AbstractArray, p) in ex-ff2
my_int_fun!(dispatch::Int64, out, V::AbstractArray, p) in ex-ff2</code></pre></div><p>Notice that because we set the <code>dispatch</code> argument to <code>Int</code>, all methods of either the mutating or allocating function require that an <code>Int</code> is passed to direct dispatch.</p><p>Let&#39;s try calling our function</p><pre><code class="language-julia">V = [π, 5.0, 0.8]
p = [0.98]
my_int_fun(V, p)  # doesn&#39;t work</code></pre><p>The above fails with</p><pre><code class="language-none">ERROR: MethodError: no method matching my_int_fun(::Array{Float64,1}, ::Array{Float64,1})</code></pre><p>Now if we call that method where the first argument is an <em>instance</em> of <code>Int</code>, it will work</p><div><pre><code class="language-julia">my_int_fun(1, V, p)</code></pre><pre><code class="language-none">2-element Array{Float64,1}:
   4.95303
 125.0</code></pre></div><p>The actual integer we pass doesn&#39;t matter</p><div><pre><code class="language-julia">my_int_fun(10_000_001, V, p)</code></pre><pre><code class="language-none">2-element Array{Float64,1}:
   4.95303
 125.0</code></pre></div><p>We can still evaluate derivatives</p><div><pre><code class="language-julia">my_int_fun(Der{1}, 1, V, p)</code></pre><pre><code class="language-none">2×3 Array{Float64,2}:
 -1.0   0.0  9.90606
  0.0  25.0  0.0</code></pre></div><p>Notice that the order of derivative comes first, then the dispatch argument, then all other function arguments.</p><p>Higher order derivatives also work</p><div><pre><code class="language-julia">my_int_fun(Der{2}, 10, V, p)</code></pre><pre><code class="language-none">2×9 SparseMatrixCSC{Float64,Int64} with 2 stored entries:
  [1, 1]  =  -1.22465e-16
  [1, 9]  =  19.8121</code></pre></div><div><pre><code class="language-julia">my_int_fun(Der{5}, 10, V, p)</code></pre><pre><code class="language-none">2-element Array{Dict{NTuple{5,Int64},Float64},1}:
 Dict((3, 3, 3, 3, 3)=&gt;158.497,(1, 1, 1, 1, 1)=&gt;-1.0)
 Dict{NTuple{5,Int64},Float64}()</code></pre></div><div><pre><code class="language-julia">my_int_fun(Der{10}, 10, V, p)</code></pre><pre><code class="language-none">2-element Array{Dict{NTuple{10,Int64},Float64},1}:
 Dict((3, 3, 3, 3, 3, 3, 3, 3, 3, 3)=&gt;5071.91,(1, 1, 1, 1, 1, 1, 1, 1, 1, 1)=&gt;-1.22465e-16)
 Dict{NTuple{10,Int64},Float64}()</code></pre></div><h2><a class="nav-anchor" id="With-grouped-args-1" href="#With-grouped-args-1">With grouped <code>args</code></a></h2><p>Finally we show one more example of how to use an associative mapping for the <code>FunctionFactory</code> <code>args</code> field to produce a function with grouped arguments.</p><div><pre><code class="language-julia">eqs = [
    :(sin(x(0)) + exp(2*x(1))),
    :(y(0) / (2 * (1 - β))),
]
args = Dict(
    :a =&gt; [(:x, 0), (:y, 0)],
    :b =&gt; [(:x, 1)]
)
params = [:β]
ff = FunctionFactory(eqs, args, params, funname=:grouped_args)
code = make_function(ff)
eval(code)</code></pre><pre><code class="language-none">(grouped_args, grouped_args!)</code></pre></div><p>Let&#39;s take a look at the methods for this function</p><div><pre><code class="language-julia">methods(grouped_args)</code></pre><pre><code class="language-none"># 5 methods for generic function &quot;grouped_args&quot;:
grouped_args(::Type{Dolang.Der{0}}, a::AbstractArray{T,1} where T, b::AbstractArray{T,1} where T, p) in ex-ff3
grouped_args(::Type{Dolang.Der{D}}, a::AbstractArray{T,1} where T, b::AbstractArray{T,1} where T, p) where D in ex-ff3
grouped_args(a::AbstractArray{T,1} where T, b::AbstractArray{T,1} where T, p) in ex-ff3
grouped_args(::Type{Dolang.Der{0}}, a::AbstractArray, b::AbstractArray, p) in ex-ff3
grouped_args(a::AbstractArray, b::AbstractArray, p) in ex-ff3</code></pre></div><p>Notice that each of theses routines have arguments for <code>a</code>, <code>b</code>, and <code>p</code> instead of just the <code>V</code> and <code>p</code> we saw in previous examples.</p><p>When we evaluate these methods we need to be sure that <code>a</code> has two elements, <code>b</code> has one, and <code>p</code> has one:</p><div><pre><code class="language-julia">a = [π, 5.0]
b = [0.8]
p = [0.98]
grouped_args(a, b, p)</code></pre><pre><code class="language-none">2-element Array{Float64,1}:
   4.95303
 125.0</code></pre></div><p>Notice we can evaluate a method where <code>a</code> and <code>b</code> are vectorized. Here <code>p</code> will be repeated as necessary</p><div><pre><code class="language-julia">grouped_args([a a+1]&#39;, [b b+1]&#39;, p)</code></pre><pre><code class="language-none">2×2 Array{Float64,2}:
  4.95303  125.0
 35.7568   150.0</code></pre></div><p>We can also evaluate a partially vectorized version of the function where only <code>a</code> is a matrix and <code>b</code> is a vector. In this case both <code>b</code> and <code>p</code> will be repeated</p><div><pre><code class="language-julia">grouped_args([a a+1]&#39;, b, p)</code></pre><pre><code class="language-none">2×2 Array{Float64,2}:
 4.95303  125.0
 4.11156  150.0</code></pre></div><p>Non-allocating versions of the function are also available</p><div><pre><code class="language-julia">out = zeros(2)
grouped_args!(out, a, b, p)
@show @allocated grouped_args!(out, a, b, p)
@show out</code></pre><pre><code class="language-none">@allocated(grouped_args!(out, a, b, p)) = 0
out = [4.95303, 125.0]
2-element Array{Float64,1}:
   4.95303
 125.0</code></pre></div><p>As of today (2017-06-13) only first order derivative code has been implemented for functions with grouped args. Trying to evaluate a derivative will result in an error that looks like this:</p><div><pre><code class="language-julia">grouped_args(Der{1}, a, b, p)</code></pre><pre><code class="language-none">([-1.0 0.0; 0.0 25.0], [9.90606; 0.0])</code></pre></div><p>Trying to evaluate any higher order derivative will result in an error that looks like this:</p><pre><code class="language-none">julia&gt; grouped_args(Der{2}, a, b, p)
ERROR: MethodError: no method matching equation_block(::Dolang.FunctionFactory{Dict{Symbol,Array{Tuple{Symbol,Int64},1}},Array{Symbol,1},Dict{Symbol,Any},DataType}, ::Type{Dolang.Der{2}})</code></pre><footer><hr/><a class="previous" href="compiler.html"><span class="direction">Previous</span><span class="title">Dolang&#39;s compiler</span></a><a class="next" href="dev/compiler.html"><span class="direction">Next</span><span class="title">Compiler internals</span></a></footer></article></body></html>
