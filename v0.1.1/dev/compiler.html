<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Compiler internals · Dolang.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Dolang.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><span class="toctext">Guide</span><ul><li><a class="toctext" href="../index.html">Dolang.jl</a></li><li><a class="toctext" href="../symbolic.html">Symbolic manipulation</a></li><li><a class="toctext" href="../compiler.html">Dolang&#39;s compiler</a></li><li><a class="toctext" href="../examples.html">Examples</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li class="current"><a class="toctext" href="compiler.html">Compiler internals</a><ul class="internal"><li><a class="toctext" href="#Expression-Blocks-1">Expression Blocks</a></li><li><a class="toctext" href="#Function-Signature-1">Function Signature</a></li><li><a class="toctext" href="#Putting-it-together-1">Putting it together</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Developer Documentation</li><li><a href="compiler.html">Compiler internals</a></li></ul><a class="edit-page" href="https://github.com/EconForge/Dolang.jl/tree/14e4cdf6ca6cc477b3622306b4a13a9f287cec36/docs/src/dev/compiler.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Compiler internals</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Compiler-internals-1" href="#Compiler-internals-1">Compiler internals</a></h1><p><strong>NOTE: 2017-06-13</strong>: These docs might be slightly out of date. They should still serve as a helpful reference if you are totally lost when reading the code, but the best way to understand what is going on is to read the code in <code>src/symbolic.jl</code> and <code>src/compiler.jl</code></p><p>These are some developer notes about the compiler inside Dolang.jl</p><p>The compiler operates through the <code>FunctionFactory</code> type. The fields of the type include the equations, symbols, and incidence tables for all equations.</p><h2><a class="nav-anchor" id="Expression-Blocks-1" href="#Expression-Blocks-1">Expression Blocks</a></h2><p>Julia functions are generated by composing multiple blocks. Each of these blocks is associated with a function that can be overloaded to customize behavior.</p><p>For a function that allocates memory for the output and returns the allocated array, we have the following blocks (in this order):</p><ol><li><p><code>allocate_block</code>: Allocates memory to hold the output of the evaluated</p></li></ol><p>equations. Memory is bound to a variable named <code>out</code></p><ol><li><p><code>param_block</code>: Unpacks items from the <code>params</code> field</p></li><li><p><code>arg_block</code>: Unpacks items from the <code>arg</code> field</p></li><li><p><code>equation_block</code>: uses the now locally defined variables from params and</p></li></ol><p>args to evaluate the equations</p><ol><li><p><code>return_block</code>: Simply returns <code>out</code></p></li></ol><p>For a mutating function that populates a pre-allocated array with the value of the function at specified values for the args and params we have:</p><ol><li><p><code>sizecheck_block</code>: Checks that the size of the <code>out</code> argument that was</p></li></ol><p>passed into the function is conformable with the input args and parameters and the equations.</p><ol><li><p><code>param_block</code>: Unpacks items from the <code>params</code> field</p></li><li><p><code>arg_block</code>: Unpacks items from the <code>arg</code> field</p></li><li><p><code>equation_block</code>: uses the now locally defined variables from params and</p></li></ol><p>args to evaluate the equations</p><ol><li><p><code>return_block</code>: Simply returns <code>out</code></p></li></ol><p>In both cases steps 2-5 are the same and are called the <code>body_block</code></p><p>The <code>allocate_block</code>, <code>size_checkblock</code>, and <code>equation_block</code> can all depend on the order of derivative to be computed. For that reason, the corresponding functions all have the signature <code>func{n}(::FunctionFactory, ::TDer{n})</code>. To implement the body of a function higher order derivatives, you only need to provide methods for these functions. Also, each of them has the second argument defaulting to <code>Der{0}</code>, so calling <code>func(ff)</code> will return the 0th order derivative (or level) version of that block.</p><h2><a class="nav-anchor" id="Function-Signature-1" href="#Function-Signature-1">Function Signature</a></h2><p>In addition to the function blocks discussed above, we also need to know the signature of each function so it can be defined.</p><p>The signature of the generated function for <code>ff::FunctionFactory</code> has the following structure:</p><p><code>ff.funname([DERIVATIVE], [DISPATCH], arg_names(ff)..., param_names(ff)...)</code></p><p>Let&#39;s take it once piece at a time:</p><ul><li><p><code>ff.funname</code> is the provided function name</p></li><li><p><code>DERIVATIVE</code> has the form <code>::Type{Dolang.Der{N}}</code>, where <code>N</code> is meant to</p></li></ul><p>specify the order(s) of the derivative to be evaluated. This allows you to use the same function name, but control which order of derivative is evaluated by passing <code>Der{N}</code> as the first argument to <code>ff.funname</code>. If <code>N == 0</code>, this section of the signature is skipped.</p><ul><li><p><code>DISPATCH</code> has the form <code>::Type{ff.dispatch}</code> where <code>ff.dispatch</code> should be</p></li></ul><p>a Julia <code>DataType</code>. This is used to create many methods for same function (i.e. multiple versions of the function with the same name), but have them be distinguishable to the Julia compiler. See example usage to see how it works. By default <code>ff.dispatch</code> is set to <code>Dolang.SkipArg</code>. When <code>ff.dispatch == SkipArg</code>, the compiler completely skips the <code>[DISPATCH]</code> section of the signature</p><ul><li><p><code>arg_names(ff)...</code> is simply the name of the arguments from <code>ff.args</code>. If</p></li></ul><p><code>ff.args</code> is a <code>Vector</code> (more specifically a <code>Dolang.FlatArgs</code>), then this will be <code>[:V]</code>. If <code>ff.args</code> is some <code>Associative</code> structure, then this will be the keys of that structure.</p><ul><li><p><code>param_names(ff)</code> is the same as <code>arg_names(ff)</code>, but applied to the</p></li></ul><p><code>ff.params</code> field</p><p>We also need a signature for the mutating version of the signature. This has the structure</p><p><code>ff.funname!([DERIVATIVE], [DISPATCH], out, arg_names(ff)..., param_names(ff)...)</code></p><p>Everything is the same as above, except that <code>ff.funname!</code> is now the original function name with <code>!</code> appended to it and there is an additional <code>out</code> argument. This is the array that should be filled with the evaluated equations and always comes _after_ arguments that drive dispatch (<code>DERIVATIVE</code> and <code>DISPATCH</code>), but _before_ args and params.</p><h2><a class="nav-anchor" id="Putting-it-together-1" href="#Putting-it-together-1">Putting it together</a></h2><p>Once you have the signature and function body, putting them together is pretty simple.</p><p>The <code>build_function</code> function will simply build <code>Expr(:function, signature, body)</code>, using the signature and body routines from above.</p><p>In a pun on the normal meaning of the <code>!</code> suffix for Julia functions, <code>build_function!</code> will build a mutating version of the function following the rules outlined above.</p><footer><hr/><a class="previous" href="../examples.html"><span class="direction">Previous</span><span class="title">Examples</span></a></footer></article></body></html>
